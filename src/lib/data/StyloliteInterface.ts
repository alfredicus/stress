import { Matrix3x3, scalarProductUnitVectors, Vector3 } from "../types"
import { fromAnglesToNormal } from "../utils/fromAnglesToNormal"
import { Data } from "./Data"
import { DataParameters } from './DataParameters'
import { FractureStrategy } from "./types"
import { TensorParameters } from "../geomeca"

/**
 * 
 * A styloliye interface is represented by a plane. Its orientation in space is defined by three parameters, as follows:
 *      Strike: clockwise angle measured from the North direction [0, 360)
 *      Dip: vertical angle, measured downward, between the horizontal and the line of greatest slope in an inclined plane [0, 90]
 *      Dip direction: (N, E, S, W) or a combination of two directions (NE, SE, SW, NW).
 *
 * The misfit value is calculated from the angle between vector 'normal' parallel to crystal fibers and the extensional stress axis Sigma 1.
 * 'normal' is computed through the private method CrystalFibersInVeinSphericalCoords.
 * @category Data
 */
  
 export class StyloliteInterface extends Data {
    protected normal: Vector3 = [0,0,0]
    protected strategy: FractureStrategy = FractureStrategy.ANGLE

    initialize(params: DataParameters[]): boolean {
        if (Number.isNaN(params[0].strike)) {
            throw new Error('Missing strike angle for Stylolite Interface' + params[0].noPlane)
        }

        if (Number.isNaN(params[0].dip)) {
            throw new Error('Missing dip angle for Stylolite Interface' + params[0].noPlane)
        }
       
        if (params[0].dip < 90 && Number.isNaN(params[0].dipDirection)) {
            throw new Error('Missing dip direction for Stylolite Interface' + params[0].noPlane)
        }

        // Convert into normal
        this.normal = fromAnglesToNormal({strike: params[0].strike, dip: params[0].dip, dipDirection: params[0].dipDirection})

        return true
    }

    check({displ, strain, stress}:{displ: Vector3, strain: Matrix3x3, stress: Matrix3x3}): boolean {
        return stress !== undefined
    }

    // This version does not consider the case in which the stress shape ratio R is close to 1 (i.e., Sigma 2 = Sigma 1) 
    //      In this particular situation, any styloliye interface containing Sigma 3 is consistent with the hypothetical stress tensor solution.
    //      In other words, the styloliye interface normal is in the plane generated by (Sigma 1, Sigma 2)
    cost({displ, strain, stress}:{displ: Vector3, strain: TensorParameters, stress: TensorParameters}): number {
        const dot = scalarProductUnitVectors({U: stress.S1, V: this.normal})

        switch(this.strategy) {
            case FractureStrategy.DOT: return 1 - Math.abs(dot)
            // Sigma 1 can be oriented in two opposite directions, thus to calculate the minimum angle we take the dot product as positive.
            default: return Math.acos( Math.abs(dot) ) / Math.PI
        }
    }



    /*
    cost({displ, strain, stress}:{displ: Vector3, strain: Matrix3x3, stress: Matrix3x3}): number {
        //      and any plane containing Sigma 3 is consistent with the stress tensor solution

        // [xx, xy, xz, yy, yz, zz]
        const sigma = [stress[0][0], stress[0][1], stress[0][2], stress[1][1], stress[1][2], stress[2][2]]
        // eigen = function calculating the 3 normalized eigenvectors (Sigma_1, Sigma_2, Sigma_3) of the stress tensor ??
        // vectors is formated like: [S1x, S1y, S1z, S2x..., S3z]
        const {values, vectors} = eigen(sigma)
        const sigma1 = [vectors[0], vectors[1], vectors[2]] as Vector3
        
        const dot = scalarProductUnitVectors({U: sigma1, V: this.normal})

        switch(this.strategy) {
            case FractureStrategy.DOT: return 1 - Math.abs(dot)
            // Sigma 1 can be oriented in two opposite directions, thus to calculate the minimum angle we take the dot product as positive.
            default: return Math.acos( Math.abs(dot) ) / Math.PI
        }
    }
    */


}
