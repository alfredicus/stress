import { Matrix3x3, scalarProductUnitVectors, Vector3 } from "../../types"
import { fromAnglesToNormal } from "../../utils/fromAnglesToNormal"
import { FractureStrategy } from "../types"
import { Engine, HypotheticalSolutionTensorParameters } from "../../geomeca"
import { DataStatus } from "../DataDescription"
import { decodePlane } from "../../helpers/PlaneHelper"
import { FractureData } from "./FractureData"
import { isPropertyDefined, setPositionIfAny } from "../../utils/assertJson"

/**
 * 
 * A styloliye interface is represented by a plane. Its orientation in space is defined by three parameters, as follows:
 *      Strike: clockwise angle measured from the North direction [0, 360)
 *      Dip: vertical angle, measured downward, between the horizontal and the line of greatest slope in an inclined plane [0, 90]
 *      Dip direction: (N, E, S, W) or a combination of two directions (NE, SE, SW, NW).
 *
 * The misfit value is calculated from the angle between vector 'normal' parallel to crystal fibers and the extensional stress axis Sigma 1.
 * 'normal' is computed through the private method CrystalFibersInVeinSphericalCoords.
 * @category Data
 */
  
 export class StyloliteInterface extends FractureData {
    protected strategy: FractureStrategy = FractureStrategy.ANGLE

    // description(): any {
    //     return {
    //         // Mandatory data: 
    //         // 0, 1    = Data number, data type (Stylolite Interface and inheriting class: Compaction Band)
    //         // ------------------------------
    //         // Plane orientation : 
    //         // 2, 3, 4 = Strike, dip, dip direction
    //         mandatory: [2, 3, 4],
    //         // Optional data:
    //         // 11, 12  = Deformation phase, relative weight 
    //         optional: [11, 12]
    //     }
    // }

    initialize(obj: any): DataStatus {
        // Call of parent class
        super.initialize(obj)

        const plane = decodePlane(obj)

        // Calculate the unit vector normal to the Plane
        this.nPlane = fromAnglesToNormal({
            strike: plane.strike,
            dip: plane.dip,
            dipDirection: plane.dipDirection
        })

        return plane.result
    }

    check({displ, strain, stress}:{displ?: Vector3, strain?: Matrix3x3, stress?: Matrix3x3}): boolean {
        return stress !== undefined
    }

    // This version does not consider the case in which the stress shape ratio R is close to 1 (i.e., Sigma 2 = Sigma 1) 
    //      In this particular situation, any styloliye interface containing Sigma 3 is consistent with the hypothetical stress tensor solution.
    //      In other words, the styloliye interface normal is in the plane generated by (Sigma 1, Sigma 2)
    cost({displ, strain, stress}:{displ?: Vector3, strain?: HypotheticalSolutionTensorParameters, stress?: HypotheticalSolutionTensorParameters}): number {
        const dot = scalarProductUnitVectors({U: stress.S1_X, V: this.normal})

        switch(this.strategy) {
            case FractureStrategy.DOT: return 1 - Math.abs(dot)
            // Sigma 1 can be oriented in two opposite directions, thus to calculate the minimum angle we take the dot product as positive.
            default: return Math.acos( Math.abs(dot) ) / Math.PI
        }
    }

    predict(engine: Engine, { displ, strain, stress }: { displ?: Vector3; strain?: HypotheticalSolutionTensorParameters; stress?: HypotheticalSolutionTensorParameters }) {
        return engine.stress(this.position).S1_X
        // const dot = scalarProductUnitVectors({U: stress.S1_X, V: this.normal})
        // return Math.acos( Math.abs(dot) ) / Math.PI
    }

}
