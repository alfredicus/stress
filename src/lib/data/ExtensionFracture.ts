import { Matrix3x3, scalarProductUnitVectors, Vector3 } from "../types"
import { fromAnglesToNormal } from "../utils/fromAnglesToNormal"
import { Data } from "./Data"
import { FractureStrategy } from "./types"
import { DataParameters } from "./DataParameters"
import { DataArguments, FractureStrategy } from "./types"
import { Direction, getDirectionFromString } from "../utils"
import { TensorParameters } from "../geomeca"
import { DataArgument, DataDescription, DataMessages } from "./DataDescription"

/**
 * @brief Represent an observed and measured joint
 * 
 * An extension fracture is represented by a plane. Its orientation in space is definedby three parameters, as follows:
 *      Strike: clockwise angle measured from the North direction [0, 360)
 *      Dip: vertical angle, measured downward, between the horizontal and the line of greatest slope in an inclined plane [0, 90]
 *      Dip direction: (N, E, S, W) or a combination of two directions (NE, SE, SW, NW).
 *
 * @category Data
 */
export class ExtensionFracture extends Data {
    protected nPlane: Vector3 = undefined
    protected strategy: FractureStrategy = FractureStrategy.ANGLE

    /*
    description(): any {
        return {
            // Mandatory data: 
            // 0, 1    =  Data number, data type (Extension Fracture and inheriting class: Dilation Band)
            // ------------------------------
            // Plane orientation : 
            // 2, 3, 4 = Strike, dip, dip direction
            mandatory: [2, 3, 4],
            // Optional data:
            // 11, 12 = Deformation phase, relative weight 
            optional: [11, 12]
        }
    }

    initialize(params: DataParameters[]): boolean {
        if (Number.isNaN(params[0].strike)) {
            throw new Error('Missing azimuth angle for Extension Fracture')
        }

        if (Number.isNaN(params[0].dip)) {
            throw new Error('Missing dip angle for Extension Fracture')
        }

        if (params[0].dip < 90 && params[0].dipDirection === undefined) {
            throw new Error('Missing dip direction for Extension Fracture')
        }

        // Convert into normal
        this.normal = fromAnglesToNormal({
            strike: params[0].strike, 
            dip: params[0].dip, 
            dipDirection: getDirectionFromString(params[0].dipDirection)
        })
        
        return true
    }
    */

    initialize(args: DataArguments): DataMessages {
        const toks = args[0]
        const result = { status: true, messages: [] }
        const arg: DataArgument = {
            toks,
            index: 0,
            data: this,
            result,
            setIndex(i: number) {
                this.index=i;
                return this
            }
        }
        
        // -----------------------------------

        const strike = DataDescription.getParameter(arg.setIndex(2))
        
        const dip = DataDescription.getParameter(arg.setIndex(3))

        // -----------------------------------

        let dipDirection = Direction.UNKOWN
        if ( (dip !== 90) && (dip !== 0) ) {
            // In the general case, the dip direction for non-horizontal and non-vertical planes
            // must be defined in terms of a geographic direction: N, S, E, W, NE, SE, SW, NW
            dipDirection = DataDescription.getParameter(arg.setIndex(4))
        }

        // Calculate the unit vector normal to the Plane
        this.nPlane = fromAnglesToNormal({strike, dip, dipDirection})

        return result
    }
   
    check({displ, strain, stress}:{displ: Vector3, strain: Matrix3x3, stress: Matrix3x3}): boolean {
        return stress !== undefined
    }

    // This version does not consider the case in which the stress shape ratio R is close to zero (i.e., Sigma 2 = Sigma 3).
    //      In this particular situation, any extension fracture containing Sigma 1 is consistent with the hypothetical stress tensor solution.
    //      In other words, the extension fracture normal is in the plane generated by (Sigma 2, Sigma 3)
    cost({displ, strain, stress}:{displ: Vector3, strain: TensorParameters, stress: TensorParameters}): number {
        const dot = scalarProductUnitVectors({U: stress.S3_Yh, V: this.nPlane})

        switch(this.strategy) {
            case FractureStrategy.DOT: return 1 - Math.abs(dot)
            // Sigma 1 can be oriented in two opposite directions, thus to calculate the minimum angle we take the dot product as positive.
            default: return Math.acos( Math.abs(dot) ) / Math.PI
        }
    }

    // cost({displ, strain, stress}:{displ: Vector3, strain: Matrix3x3, stress: Matrix3x3}): number {
    //     // [xx, xy, xz, yy, yz, zz]
    //     const sigma = [stress[0][0], stress[0][1], stress[0][2], stress[1][1], stress[1][2], stress[2][2]]
    //     // eigen = function calculating the 3 normalized eigenvectors (Sigma_1, Sigma_2, Sigma_3) of the stress tensor ??
    //     // vectors is formated like: [S1x, S1y, S1z, S2x..., S3z]
    //     const {values, vectors} = eigen(sigma)
    //     const s = [vectors[6], vectors[7], vectors[8]] as Vector3
    //     // dot = scalar product between 2 unitary vectors Sigma_3 . normal = cos(angle)
    //     const dot = scalarProductUnitVectors({U: s, V: this.normal})

    //     switch(this.strategy) {
    //         case FractureStrategy.DOT: return 1 - Math.abs(dot)
    //         // Sigma 3 can be oriented in two opposite directions, thus to calculate the minimum angle we take the dot product as positive.
    //         default: return Math.acos(Math.abs(dot))/Math.PI
    //     }
    // }
}
